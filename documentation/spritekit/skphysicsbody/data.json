{
  "path": "/documentation/spritekit/skphysicsbody",
  "type": "Class",
  "name": "SKPhysicsBody",
  "desc": "An object that adds physics simulation to a node.",
  "items": [
    {
      "name": "init(circleOfRadius: CGFloat)",
      "desc": "Creates a circular physics body centered on the owning node’s origin."
    },
    {
      "name": "init(circleOfRadius: CGFloat, center: CGPoint)",
      "desc": "Creates a circular physics body centered on an arbitrary point."
    },
    {
      "name": "init(rectangleOf: CGSize)",
      "desc": "Creates a rectangular physics body centered on the owning node’s origin."
    },
    {
      "name": "init(rectangleOf: CGSize, center: CGPoint)",
      "desc": "Creates a rectangular physics body centered on an arbitrary point."
    },
    {
      "name": "init(polygonFrom: CGPath)",
      "desc": "Creates a polygonal physics body."
    },
    {
      "name": "init(texture: SKTexture, size: CGSize)",
      "desc": "Creates a physics body from the contents of a texture."
    },
    {
      "name": "init(texture: SKTexture, alphaThreshold: Float, size: CGSize)",
      "desc": "Creates a physics body from the contents of a texture, capturing only the texels that exceed a specified transparency value."
    },
    {
      "name": "init(bodies: [SKPhysicsBody])",
      "desc": "Creates a physics body that's shaped like a union of the argument physics bodies."
    },
    {
      "name": "init(edgeLoopFrom: CGRect)",
      "desc": "Creates an edge loop from a rectangle."
    },
    {
      "name": "init(edgeFrom: CGPoint, to: CGPoint)",
      "desc": "Creates an edge between two points."
    },
    {
      "name": "init(edgeLoopFrom: CGPath)",
      "desc": "Creates an edge loop from a path."
    },
    {
      "name": "init(edgeChainFrom: CGPath)",
      "desc": "Creates an edge chain from a path."
    },
    {
      "name": "var affectedByGravity: Bool",
      "desc": "A Boolean value that indicates whether this physics body is affected by the physics world’s gravity."
    },
    {
      "name": "var allowsRotation: Bool",
      "desc": "A Boolean value that indicates whether the physics body is affected by angular forces and impulses applied to it."
    },
    {
      "name": "var isDynamic: Bool",
      "desc": "A Boolean value that indicates whether the physics body is moved by the physics simulation."
    },
    {
      "name": "var mass: CGFloat",
      "desc": "The mass of the body, in kilograms."
    },
    {
      "name": "var density: CGFloat",
      "desc": "The density of the object, in kilograms per square meter."
    },
    {
      "name": "var area: CGFloat",
      "desc": "The area covered by the body."
    },
    {
      "name": "var friction: CGFloat",
      "desc": "The roughness of the surface of the physics body."
    },
    {
      "name": "var restitution: CGFloat",
      "desc": "The bounciness of the physics body."
    },
    {
      "name": "var linearDamping: CGFloat",
      "desc": "A property that reduces the body’s linear velocity."
    },
    {
      "name": "var angularDamping: CGFloat",
      "desc": "A property that reduces the body’s rotational velocity."
    },
    {
      "name": "var categoryBitMask: UInt32",
      "desc": "A mask that defines which categories this physics body belongs to."
    },
    {
      "name": "var collisionBitMask: UInt32",
      "desc": "A mask that defines which categories of physics bodies can collide with this physics body."
    },
    {
      "name": "var usesPreciseCollisionDetection: Bool",
      "desc": "A Boolean value that determines whether the physics world uses an iterative collision detection algorithm."
    },
    {
      "name": "var contactTestBitMask: UInt32",
      "desc": "A mask that defines which categories of physics bodies cause intersection notifications with this physics body."
    },
    {
      "name": "func allContactedBodies() -> [SKPhysicsBody]",
      "desc": "The physics bodies that this physics body is in contact with."
    },
    {
      "name": "func applyForce(CGVector)",
      "desc": "Applies a force to the center of gravity of a physics body."
    },
    {
      "name": "func applyTorque(CGFloat)",
      "desc": "Applies torque to an object."
    },
    {
      "name": "func applyForce(CGVector, at: CGPoint)",
      "desc": "Applies a force to a specific point of a physics body."
    },
    {
      "name": "func applyImpulse(CGVector)",
      "desc": "Applies an impulse to the center of gravity of a physics body."
    },
    {
      "name": "func applyAngularImpulse(CGFloat)",
      "desc": "Applies an impulse that imparts angular momentum to an object."
    },
    {
      "name": "func applyImpulse(CGVector, at: CGPoint)",
      "desc": "Applies an impulse to a specific point of a physics body."
    },
    {
      "name": "var velocity: CGVector",
      "desc": "The physics body’s velocity vector, measured in meters per second."
    },
    {
      "name": "var angularVelocity: CGFloat",
      "desc": "The physics body’s angular speed."
    },
    {
      "name": "var isResting: Bool",
      "desc": "A Boolean property that indicates whether the object is at rest within the physics simulation."
    },
    {
      "name": "var node: SKNode?",
      "desc": "The node that this body is connected to."
    },
    {
      "name": "var joints: [SKPhysicsJoint]",
      "desc": "The joints connected to this physics body."
    },
    {
      "name": "var fieldBitMask: UInt32",
      "desc": "A mask that defines which categories of physics fields can exert forces on this physics body."
    },
    {
      "name": "var charge: CGFloat",
      "desc": "The electrical charge of the physics body."
    },
    {
      "name": "var pinned: Bool",
      "desc": "A Boolean value that indicates whether the physics body’s node is pinned to its parent node."
    }
  ],
  "declaration": "class SKPhysicsBody : NSObject",
  "inheritsFrom": [
    "NSObject"
  ],
  "conformsTo": [
    "NSCopying",
    "NSSecureCoding"
  ]
}