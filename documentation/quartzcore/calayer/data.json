{
  "path": "/documentation/quartzcore/calayer",
  "type": "Class",
  "name": "CALayer",
  "desc": "An object that manages image-based content and allows you to perform animations on that content.",
  "items": [
    {
      "name": "init()",
      "desc": "Returns an initialized CALayer object."
    },
    {
      "name": "init(layer: Any)",
      "desc": "Override to copy or initialize custom fields of the specified layer."
    },
    {
      "name": "init(remoteClientId: UInt32)",
      "desc": "Initializes a layer with a remote client ID."
    },
    {
      "name": "func presentation() -> Self?",
      "desc": "Returns a copy of the presentation layer object that represents the state of the layer as it currently appears onscreen."
    },
    {
      "name": "func model() -> Self",
      "desc": "Returns the model layer object associated with the receiver, if any."
    },
    {
      "name": "var delegate: CALayerDelegate?",
      "desc": "The layer’s delegate object."
    },
    {
      "name": "var contents: Any?",
      "desc": "An object that provides the contents of the layer. Animatable."
    },
    {
      "name": "var contentsRect: CGRect",
      "desc": "The rectangle, in the unit coordinate space, that defines the portion of the layer’s contents that should be used. Animatable."
    },
    {
      "name": "var contentsCenter: CGRect",
      "desc": "The rectangle that defines how the layer contents are scaled if the layer’s contents are resized. Animatable."
    },
    {
      "name": "func display()",
      "desc": "Reloads the content of this layer."
    },
    {
      "name": "func draw(in: CGContext)",
      "desc": "Draws the layer’s content using the specified graphics context."
    },
    {
      "name": "var contentsGravity: CALayerContentsGravity",
      "desc": "A constant that specifies how the layer's contents are positioned or scaled within its bounds."
    },
    {
      "name": "var opacity: Float",
      "desc": "The opacity of the receiver. Animatable."
    },
    {
      "name": "var isHidden: Bool",
      "desc": "A Boolean indicating whether the layer is displayed. Animatable."
    },
    {
      "name": "var masksToBounds: Bool",
      "desc": "A Boolean indicating whether sublayers are clipped to the layer’s bounds. Animatable."
    },
    {
      "name": "var mask: CALayer?",
      "desc": "An optional layer whose alpha channel is used to mask the layer’s content."
    },
    {
      "name": "var isDoubleSided: Bool",
      "desc": "A Boolean indicating whether the layer displays its content when facing away from the viewer. Animatable."
    },
    {
      "name": "var cornerRadius: CGFloat",
      "desc": "The radius to use when drawing rounded corners for the layer’s background. Animatable."
    },
    {
      "name": "var maskedCorners: CACornerMask"
    },
    {
      "name": "struct CACornerMask"
    },
    {
      "name": "var borderWidth: CGFloat",
      "desc": "The width of the layer’s border. Animatable."
    },
    {
      "name": "var borderColor: CGColor?",
      "desc": "The color of the layer’s border. Animatable."
    },
    {
      "name": "var backgroundColor: CGColor?",
      "desc": "The background color of the receiver. Animatable."
    },
    {
      "name": "var shadowOpacity: Float",
      "desc": "The opacity of the layer’s shadow. Animatable."
    },
    {
      "name": "var shadowRadius: CGFloat",
      "desc": "The blur radius (in points) used to render the layer’s shadow. Animatable."
    },
    {
      "name": "var shadowOffset: CGSize",
      "desc": "The offset (in points) of the layer’s shadow. Animatable."
    },
    {
      "name": "var shadowColor: CGColor?",
      "desc": "The color of the layer’s shadow. Animatable."
    },
    {
      "name": "var shadowPath: CGPath?",
      "desc": "The shape of the layer’s shadow. Animatable."
    },
    {
      "name": "var style: [AnyHashable : Any]?",
      "desc": "An optional dictionary used to store property values that aren't explicitly defined by the layer."
    },
    {
      "name": "var allowsEdgeAntialiasing: Bool",
      "desc": "A Boolean indicating whether the layer is allowed to perform edge antialiasing."
    },
    {
      "name": "var allowsGroupOpacity: Bool",
      "desc": "A Boolean indicating whether the layer is allowed to composite itself as a group separate from its parent."
    },
    {
      "name": "var filters: [Any]?",
      "desc": "An array of Core Image filters to apply to the contents of the layer and its sublayers. Animatable."
    },
    {
      "name": "var compositingFilter: Any?",
      "desc": "A CoreImage filter used to composite the layer and the content behind it. Animatable."
    },
    {
      "name": "var backgroundFilters: [Any]?",
      "desc": "An array of Core Image filters to apply to the content immediately behind the layer. Animatable."
    },
    {
      "name": "var minificationFilter: CALayerContentsFilter",
      "desc": "The filter used when reducing the size of the content."
    },
    {
      "name": "var minificationFilterBias: Float",
      "desc": "The bias factor used by the minification filter to determine the levels of detail."
    },
    {
      "name": "var magnificationFilter: CALayerContentsFilter",
      "desc": "The filter used when increasing the size of the content."
    },
    {
      "name": "var isOpaque: Bool",
      "desc": "A Boolean value indicating whether the layer contains completely opaque content."
    },
    {
      "name": "var edgeAntialiasingMask: CAEdgeAntialiasingMask",
      "desc": "A bitmask defining how the edges of the receiver are rasterized."
    },
    {
      "name": "func contentsAreFlipped() -> Bool",
      "desc": "Returns a Boolean indicating whether the layer content is implicitly flipped when rendered."
    },
    {
      "name": "var isGeometryFlipped: Bool",
      "desc": "A Boolean that indicates whether the geometry of the layer and its sublayers is flipped vertically."
    },
    {
      "name": "var drawsAsynchronously: Bool",
      "desc": "A Boolean indicating whether drawing commands are deferred and processed asynchronously in a background thread."
    },
    {
      "name": "var shouldRasterize: Bool",
      "desc": "A Boolean that indicates whether the layer is rendered as a bitmap before compositing. Animatable"
    },
    {
      "name": "var rasterizationScale: CGFloat",
      "desc": "The scale at which to rasterize content, relative to the coordinate space of the layer. Animatable"
    },
    {
      "name": "var contentsFormat: CALayerContentsFormat",
      "desc": "A hint for the desired storage format of the layer contents."
    },
    {
      "name": "func render(in: CGContext)",
      "desc": "Renders the layer and its sublayers into the specified context."
    },
    {
      "name": "var frame: CGRect",
      "desc": "The layer’s frame rectangle."
    },
    {
      "name": "var bounds: CGRect",
      "desc": "The layer’s bounds rectangle. Animatable."
    },
    {
      "name": "var position: CGPoint",
      "desc": "The layer’s position in its superlayer’s coordinate space. Animatable."
    },
    {
      "name": "var zPosition: CGFloat",
      "desc": "The layer’s position on the z axis. Animatable."
    },
    {
      "name": "var anchorPointZ: CGFloat",
      "desc": "The anchor point for the layer’s position along the z axis. Animatable."
    },
    {
      "name": "var anchorPoint: CGPoint",
      "desc": "Defines the anchor point of the layer's bounds rectangle. Animatable."
    },
    {
      "name": "var contentsScale: CGFloat",
      "desc": "The scale factor applied to the layer."
    },
    {
      "name": "var transform: CATransform3D",
      "desc": "The transform applied to the layer’s contents. Animatable."
    },
    {
      "name": "var sublayerTransform: CATransform3D",
      "desc": "Specifies the transform to apply to sublayers when rendering. Animatable."
    },
    {
      "name": "func affineTransform() -> CGAffineTransform",
      "desc": "Returns an affine version of the layer’s transform."
    },
    {
      "name": "func setAffineTransform(CGAffineTransform)",
      "desc": "Sets the layer’s transform to the specified affine transform."
    },
    {
      "name": "var sublayers: [CALayer]?",
      "desc": "An array containing the layer’s sublayers."
    },
    {
      "name": "var superlayer: CALayer?",
      "desc": "The superlayer of the layer."
    },
    {
      "name": "func addSublayer(CALayer)",
      "desc": "Appends the layer to the layer’s list of sublayers."
    },
    {
      "name": "func removeFromSuperlayer()",
      "desc": "Detaches the layer from its parent layer."
    },
    {
      "name": "func insertSublayer(CALayer, at: UInt32)",
      "desc": "Inserts the specified layer into the receiver’s list of sublayers at the specified index."
    },
    {
      "name": "func insertSublayer(CALayer, below: CALayer?)",
      "desc": "Inserts the specified sublayer below a different sublayer that already belongs to the receiver."
    },
    {
      "name": "func insertSublayer(CALayer, above: CALayer?)",
      "desc": "Inserts the specified sublayer above a different sublayer that already belongs to the receiver."
    },
    {
      "name": "func replaceSublayer(CALayer, with: CALayer)",
      "desc": "Replaces the specified sublayer with a different layer object."
    },
    {
      "name": "func setNeedsDisplay()",
      "desc": "Marks the layer’s contents as needing to be updated."
    },
    {
      "name": "func setNeedsDisplay(CGRect)",
      "desc": "Marks the region within the specified rectangle as needing to be updated."
    },
    {
      "name": "var needsDisplayOnBoundsChange: Bool",
      "desc": "A Boolean indicating whether the layer contents must be updated when its bounds rectangle changes."
    },
    {
      "name": "func displayIfNeeded()",
      "desc": "Initiates the update process for a layer if it is currently marked as needing an update."
    },
    {
      "name": "func needsDisplay() -> Bool",
      "desc": "Returns a Boolean indicating whether the layer has been marked as needing an update."
    },
    {
      "name": "class func needsDisplay(forKey: String) -> Bool",
      "desc": "Returns a Boolean indicating whether changes to the specified key require the layer to be redisplayed."
    },
    {
      "name": "func add(CAAnimation, forKey: String?)",
      "desc": "Add the specified animation object to the layer’s render tree."
    },
    {
      "name": "func animation(forKey: String) -> CAAnimation?",
      "desc": "Returns the animation object with the specified identifier."
    },
    {
      "name": "func removeAllAnimations()",
      "desc": "Remove all animations attached to the layer."
    },
    {
      "name": "func removeAnimation(forKey: String)",
      "desc": "Remove the animation object with the specified key."
    },
    {
      "name": "func animationKeys() -> [String]?",
      "desc": "Returns an array of strings that identify the animations currently attached to the layer."
    },
    {
      "name": "var layoutManager: CALayoutManager?",
      "desc": "The object responsible for laying out the layer’s sublayers."
    },
    {
      "name": "func setNeedsLayout()",
      "desc": "Invalidates the layer’s layout and marks it as needing an update."
    },
    {
      "name": "func layoutSublayers()",
      "desc": "Tells the layer to update its layout."
    },
    {
      "name": "func layoutIfNeeded()",
      "desc": "Recalculate the receiver’s layout, if required."
    },
    {
      "name": "func needsLayout() -> Bool",
      "desc": "Returns a Boolean indicating whether the layer has been marked as needing a layout update."
    },
    {
      "name": "var autoresizingMask: CAAutoresizingMask",
      "desc": "A bitmask defining how the layer is resized when the bounds of its superlayer changes."
    },
    {
      "name": "func resize(withOldSuperlayerSize: CGSize)",
      "desc": "Informs the receiver that the size of its superlayer changed."
    },
    {
      "name": "func resizeSublayers(withOldSize: CGSize)",
      "desc": "Informs the receiver’s sublayers that the receiver’s size has changed."
    },
    {
      "name": "func preferredFrameSize() -> CGSize",
      "desc": "Returns the preferred size of the layer in the coordinate space of its superlayer."
    },
    {
      "name": "var constraints: [CAConstraint]?",
      "desc": "The constraints used to position current layer’s sublayers."
    },
    {
      "name": "func addConstraint(CAConstraint)",
      "desc": "Adds the specified constraint to the layer."
    },
    {
      "name": "func action(forKey: String) -> CAAction?",
      "desc": "Returns the action object assigned to the specified key."
    },
    {
      "name": "var actions: [String : CAAction]?",
      "desc": "A dictionary containing layer actions."
    },
    {
      "name": "class func defaultAction(forKey: String) -> CAAction?",
      "desc": "Returns the default action for the current class."
    },
    {
      "name": "func convert(CGPoint, from: CALayer?) -> CGPoint",
      "desc": "Converts the point from the specified layer’s coordinate system to the receiver’s coordinate system."
    },
    {
      "name": "func convert(CGPoint, to: CALayer?) -> CGPoint",
      "desc": "Converts the point from the receiver’s coordinate system to the specified layer’s coordinate system."
    },
    {
      "name": "func convert(CGRect, from: CALayer?) -> CGRect",
      "desc": "Converts the rectangle from the specified layer’s coordinate system to the receiver’s coordinate system."
    },
    {
      "name": "func convert(CGRect, to: CALayer?) -> CGRect",
      "desc": "Converts the rectangle from the receiver’s coordinate system to the specified layer’s coordinate system."
    },
    {
      "name": "func convertTime(CFTimeInterval, from: CALayer?) -> CFTimeInterval",
      "desc": "Converts the time interval from the specified layer’s time space to the receiver’s time space."
    },
    {
      "name": "func convertTime(CFTimeInterval, to: CALayer?) -> CFTimeInterval",
      "desc": "Converts the time interval from the receiver’s time space to the specified layer’s time space"
    },
    {
      "name": "func hitTest(CGPoint) -> CALayer?",
      "desc": "Returns the farthest descendant of the receiver in the layer hierarchy (including itself) that contains the specified point."
    },
    {
      "name": "func contains(CGPoint) -> Bool",
      "desc": "Returns whether the receiver contains a specified point."
    },
    {
      "name": "var visibleRect: CGRect",
      "desc": "The visible region of the layer in its own coordinate space."
    },
    {
      "name": "func scroll(CGPoint)",
      "desc": "Initiates a scroll in the layer’s closest ancestor scroll layer so that the specified point lies at the origin of the scroll layer."
    },
    {
      "name": "func scrollRectToVisible(CGRect)",
      "desc": "Initiates a scroll in the layer’s closest ancestor scroll layer so that the specified rectangle becomes visible."
    },
    {
      "name": "var name: String?",
      "desc": "The name of the receiver."
    },
    {
      "name": "func shouldArchiveValue(forKey: String) -> Bool",
      "desc": "Returns a Boolean indicating whether the value of the specified key should be archived."
    },
    {
      "name": "class func defaultValue(forKey: String) -> Any?",
      "desc": "Specifies the default value associated with the specified key."
    },
    {
      "name": "struct CAAutoresizingMask",
      "desc": "These constants are used by the autoresizingMask property."
    },
    {
      "name": "struct CAEdgeAntialiasingMask",
      "desc": "This mask is used by the edgeAntialiasingMask property."
    },
    {
      "name": "struct CATransform3D",
      "desc": "The standard transform matrix used throughout Core Animation."
    },
    {
      "name": "var cornerCurve: CALayerCornerCurve"
    },
    {
      "name": "class func cornerCurveExpansionFactor(CALayerCornerCurve) -> CGFloat"
    }
  ],
  "declaration": "class CALayer : NSObject",
  "inheritsFrom": [
    "NSObject"
  ],
  "conformsTo": [
    "CAMediaTiming",
    "NSSecureCoding"
  ]
}