{
  "path": "/documentation/swift/range",
  "type": "Generic Structure",
  "name": "Range",
  "desc": "A half-open interval from a lower bound up to, but not including, an upper bound.",
  "items": [
    {
      "name": "static func ..< (Self, Self) -> Range<Self>",
      "desc": "Returns a half-open range that contains its lower bound but not its upper bound."
    },
    {
      "name": "func relative<C>(to: C) -> Range<Bound>",
      "desc": "Returns the range of indices described by this range expression within the given collection."
    },
    {
      "name": "init?(NSRange, in: String)",
      "desc": "Available when Bound is String.Index."
    },
    {
      "name": "init?<S>(NSRange, in: S)",
      "desc": "Available when Bound is String.Index."
    },
    {
      "name": "var isEmpty: Bool",
      "desc": "A Boolean value indicating whether the range contains no elements."
    },
    {
      "name": "let lowerBound: Bound",
      "desc": "The range’s lower bound."
    },
    {
      "name": "let upperBound: Bound",
      "desc": "The range’s upper bound."
    },
    {
      "name": "func contains(Bound) -> Bool",
      "desc": "Returns a Boolean value indicating whether the given element is contained within the range."
    },
    {
      "name": "static func ~= (Range<Bound>, Bound) -> Bool",
      "desc": "Returns a Boolean value indicating whether a value is included in a range."
    },
    {
      "name": "func clamped(to: Range<Bound>) -> Range<Bound>",
      "desc": "Returns a copy of this range clamped to the given limiting range."
    },
    {
      "name": "init?(NSRange)",
      "desc": "Available when Bound is Int."
    },
    {
      "name": "init?(NSRange)",
      "desc": "Available when Bound conforms to BinaryInteger."
    },
    {
      "name": "static func == (Range<Bound>, Range<Bound>) -> Bool",
      "desc": "Returns a Boolean value indicating whether two ranges are equal."
    },
    {
      "name": "static func != (Range<Bound>, Range<Bound>) -> Bool",
      "desc": "Returns a Boolean value indicating whether two values are not equal."
    },
    {
      "name": "func overlaps(Range<Bound>) -> Bool",
      "desc": "Returns a Boolean value indicating whether this range and the given range contain an element in common."
    },
    {
      "name": "func overlaps(ClosedRange<Bound>) -> Bool",
      "desc": "Returns a Boolean value indicating whether this range and the given range contain an element in common."
    },
    {
      "name": "func hash(into: inout Hasher)",
      "desc": "Hashes the essential components of this value by feeding them into the given hasher."
    },
    {
      "name": "var description: String",
      "desc": "A textual representation of the range."
    },
    {
      "name": "var debugDescription: String",
      "desc": "A textual representation of the range, suitable for debugging."
    },
    {
      "name": "var customMirror: Mirror",
      "desc": "The custom mirror for this instance."
    },
    {
      "name": "func encode(to: Encoder)",
      "desc": "Encodes this value into the given encoder."
    },
    {
      "name": "init(from: Decoder)",
      "desc": "Creates a new instance by decoding from the given decoder."
    },
    {
      "name": "init(uncheckedBounds: (lower: Bound, upper: Bound))",
      "desc": "Creates an instance with the given bounds."
    },
    {
      "name": "var hashValue: Int",
      "desc": "The hash value."
    },
    {
      "name": "init?<S>(NSRange, in: S)",
      "desc": "Available when Bound is AttributedString.Index."
    },
    {
      "name": "init?<R, S>(R, in: S)",
      "desc": "Available when Bound is AttributedString.Index."
    },
    {
      "name": "init?<R, S>(R, in: S)",
      "desc": "Available when Bound is String.Index."
    },
    {
      "name": "func formatted() -> String",
      "desc": "Available when Bound is Date."
    },
    {
      "name": "func formatted<S>(S) -> S.FormatOutput",
      "desc": "Available when Bound is Date."
    },
    {
      "name": "func formatted(date: Date.IntervalFormatStyle.DateStyle, time: Date.IntervalFormatStyle.TimeStyle) -> String",
      "desc": "Available when Bound is Date."
    },
    {
      "name": "func relative(toShapedArrayAxis: Range<Int>) -> Range<Int>",
      "desc": "Available when Bound is Int."
    },
    {
      "name": "static func upToNextMajor(from: Version) -> Range<Bound>"
    },
    {
      "name": "static func upToNextMinor(from: Version) -> Range<Bound>"
    }
  ],
  "declaration": "@frozen struct Range<Bound> where Bound : Comparable",
  "conformsTo": [
    "CustomDebugStringConvertible",
    "CustomReflectable",
    "CustomStringConvertible",
    "Decodable",
    "Encodable",
    "Equatable",
    "Hashable",
    "MLShapedArrayRangeExpression",
    "RangeExpression"
  ]
}